diff --git a/src/impls.rs b/src/impls.rs
index 04c92c57..03cf1f18 100644
--- a/src/impls.rs
+++ b/src/impls.rs
@@ -73,14 +73,12 @@ impl<T: Config> Pallet<T> {
 		Ok(())
 	}
 
-	/* ðŸš§ TODO ðŸš§: Create a new internal function `do_buy_kitty`:
-		- Inputs to the function are:
-			- `buyer` which is `T::AccountId`.
-			- `kitty_id` which is `[u8; 32]`.
-			- `price` which is `BalanceOf<T>`.
-		- It returns `DispatchResult`.
-		- The internal logic, for now, should be:
-			- `Self::deposit_event` with `Event::<T>::Sold` and the appropriate params.
-			- Return `Ok(())`.
-	*/
+	pub fn do_buy_kitty(
+		buyer: T::AccountId,
+		kitty_id: [u8; 32],
+		price: BalanceOf<T>,
+	) -> DispatchResult {
+		Self::deposit_event(Event::<T>::Sold { buyer, kitty_id, price });
+		Ok(())
+	}
 }
diff --git a/src/lib.rs b/src/lib.rs
index 8c3eb2e6..4a8d2b1b 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -56,11 +56,7 @@ pub mod pallet {
 		Created { owner: T::AccountId },
 		Transferred { from: T::AccountId, to: T::AccountId, kitty_id: [u8; 32] },
 		PriceSet { owner: T::AccountId, kitty_id: [u8; 32], new_price: Option<BalanceOf<T>> },
-		/* ðŸš§ TODO ðŸš§: Create a new `Event` called `Sold` with the following parameters:
-			- `buyer` which is `T::AccountId`.
-			- `kitty_id` which is `[u8; 32]`.
-			- `price` which is `BalanceOf<T>`.
-		*/
+		Sold { buyer: T::AccountId, kitty_id: [u8; 32], price: BalanceOf<T> },
 	}
 
 	#[pallet::error]
@@ -102,16 +98,14 @@ pub mod pallet {
 			Ok(())
 		}
 
-		/* ðŸš§ TODO ðŸš§: Create a new callable function `buy_kitty`:
-			- Inputs to the function are:
-				- `origin` which is `OriginFor<T>`.
-				- `kitty_id` which is `[u8; 32]`.
-				- `max_price` which is `BalanceOf<T>`.
-			- It returns `DispatchResult`.
-			- The internal logic should be:
-				- Extract `who` using `ensure_signed` on `origin`.
-				- Call `Self::do_buy_kitty` using appropriate params, and propagating the result.
-				- Return `Ok(())`.
-		*/
+		pub fn buy_kitty(
+			origin: OriginFor<T>,
+			kitty_id: [u8; 32],
+			max_price: BalanceOf<T>,
+		) -> DispatchResult {
+			let who = ensure_signed(origin)?;
+			Self::do_buy_kitty(who, kitty_id, max_price)?;
+			Ok(())
+		}
 	}
 }
diff --git a/src/tests.rs b/src/tests.rs
index c7f1af6a..91905422 100644
--- a/src/tests.rs
+++ b/src/tests.rs
@@ -356,3 +356,20 @@ fn set_price_logic_works() {
 		assert_eq!(kitty.price, Some(1337));
 	})
 }
+
+#[test]
+fn do_buy_kitty_emits_event() {
+	new_test_ext().execute_with(|| {
+		// We need to set block number to 1 to view events.
+		System::set_block_number(1);
+		assert_ok!(PalletKitties::create_kitty(RuntimeOrigin::signed(ALICE)));
+		let kitty_id = Kitties::<TestRuntime>::iter_keys().collect::<Vec<_>>()[0];
+		assert_ok!(PalletKitties::set_price(RuntimeOrigin::signed(ALICE), kitty_id, Some(1337)));
+		assert_ok!(PalletBalances::mint_into(&BOB, 100_000));
+		assert_ok!(PalletKitties::buy_kitty(RuntimeOrigin::signed(BOB), kitty_id, 1337));
+		// Assert the last event by our blockchain is the `Created` event with the correct owner.
+		System::assert_last_event(
+			Event::<TestRuntime>::Sold { buyer: BOB, kitty_id, price: 1337 }.into(),
+		);
+	})
+}
