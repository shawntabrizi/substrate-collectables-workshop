diff --git a/src/impls.rs b/src/impls.rs
index c486f9ed..79ec6585 100644
--- a/src/impls.rs
+++ b/src/impls.rs
@@ -64,13 +64,10 @@ impl<T: Config> Pallet<T> {
 		kitty_id: [u8; 32],
 		new_price: Option<BalanceOf<T>>,
 	) -> DispatchResult {
-		/* ðŸš§ TODO ðŸš§: Create the logic for setting the Kitty price:
-			- Create a mutable `kitty` by calling `get` on `Kitties` with `kitty_id`.
-				- Return an error if the kitty doesn't exist by returning `Error::<T>::NoKitty`.
-			- `ensure!` that the `kitty.owner` is equal to the `caller` else return `Error::<T>::NotOwner`.
-			- Set the `kitty.price` to `new_price`.
-			- Insert the modified `kitty` back into the `Kitties` map under `kitty_id`.
-		*/
+		let mut kitty = Kitties::<T>::get(kitty_id).ok_or(Error::<T>::NoKitty)?;
+		ensure!(kitty.owner == caller, Error::<T>::NotOwner);
+		kitty.price = new_price;
+		Kitties::<T>::insert(kitty_id, kitty);
 
 		Self::deposit_event(Event::<T>::PriceSet { owner: caller, kitty_id, new_price });
 		Ok(())
diff --git a/src/tests.rs b/src/tests.rs
index 4c486fd5..77ffa1bc 100644
--- a/src/tests.rs
+++ b/src/tests.rs
@@ -325,3 +325,16 @@ fn set_price_emits_event() {
 		);
 	})
 }
+
+#[test]
+fn set_price_logic_works() {
+	new_test_ext().execute_with(|| {
+		assert_ok!(PalletKitties::create_kitty(RuntimeOrigin::signed(ALICE)));
+		let kitty = &Kitties::<TestRuntime>::iter_values().collect::<Vec<_>>()[0];
+		assert_eq!(kitty.price, None);
+		let kitty_id = kitty.dna;
+		assert_ok!(PalletKitties::set_price(RuntimeOrigin::signed(ALICE), kitty_id, Some(1337)));
+		let kitty = Kitties::<TestRuntime>::get(kitty_id).unwrap();
+		assert_eq!(kitty.price, Some(1337));
+	})
+}
